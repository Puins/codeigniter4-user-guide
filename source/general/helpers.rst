################
辅助函数
################

顾名思义，辅助函数可以帮助您完成任务。每个辅助函数文件只是特定类别中功能的集合。有 **URL 辅助函数** 可帮助创建链接，有 **Form 辅助函数** 可帮助您创建表单元素，**Text 辅助函数** 可执行各种文本格式设置例程，**Cookie 辅助函数** 可设置和读取Cookie，**File 辅助函数** 可帮助您处理文件等。

.. contents::
    :local:
    :depth: 2

与CodeIgniter中的大多数其他系统不同，辅助函数不是以面向对象的方式编写的。它们是简单的程序函数。每个辅助函数执行一项特定任务，而不依赖于其他函数。

默认情况下，CodeIgniter不会加载辅助函数文件，因此使用辅助函数的第一步是加载它。加载后，它将在您的 :doc:`控制器 </incoming/controllers>` 和 :doc:`视图 </outgoing/views>` 中全局可用。

辅助函数通常存储在 **system/Helpers** 或 **app/Helpers** 目录中。CodeIgniter将首先在 **app/Helpers** 目录中查找。如果目录不存在或指定的辅助函数不存在，则CI会在全局 **system/Helpers** 目录中查找。

加载辅助函数
================

使用以下方法加载辅助函数非常简单::

	helper('name');

其中，**name** 是辅助函数的文件名，并不需要带有 `.php` 的文件扩展名或者是 ``helper`` 这部分。

例如，要加载名为 **cookie_helper.php** 的 **Cookie Helper** ，您可以这样做::

	helper('cookie');

如果您一次需要加载多个辅助函数，则可以传入一个文件名数组，所有文件名都将被加载::

	helper(['cookie', 'date']);

可以在控制器方法中的任何地方（甚至在你的视图文件里，虽然这样做并不符合最佳实践）加载辅助函数，只要在使用它之前将其加载即可。您可以在控制器构造函数中加载辅助函数，以便它们在任何函数中自动可用，也可以在需要它的特定函数中加载辅助函数。

.. note:: 辅助函数的加载方法并不会返回值，所以请不要尝试将它赋值给一个变量。请如上所示调用即可。

.. note:: URL辅助函数文件总是会自动加载，因此你不需要手动加载它。

从非标准位置加载
-----------------------------------

辅助函数文件可以从 **app/Helpers** 目录和 **system/Helpers** 目录外被加载， 只要它们所处的路径可以通过 :doc:`自动加载器配置文件 <../concepts/autoloader>` 中的PSR-4部分所配置的命名空间定位。 你可以为辅助函数文件用命名空间作为前缀来起名，从而使其可被定位。在命名空间所处的目录下，加载器期望该文件存在于命名空间中一个名为 ``Helpers`` 的子目录下。 以下是一个帮助理解的例子。

举例来说，假设我们把所有博客相关的代码都放在了我们的命名空间 ``Example\Blog`` 中。而文件存在于我们服务器的 **/Modules/Blog/** 命名空间下。 那么我们就应该把博客模块对应的辅助函数文件放在 **/Modules/Blog/Helpers/** 命名空间里。**blog_helper** 文件就应该位于 **/Modules/Blog/Helpers/blog_helper.php** 的位置。 在控制器中我们可以使用如下指令来加载该辅助函数文件::

	helper('Modules\Blog\blog');

.. note:: 以这种方式加载的文件中的功能并不是真正带有命名空间的。命名空间只是用作查找文件的便捷方式。		

使用辅助函数
==============

加载包含要使用的功能的辅助函数文件后，将以与标准PHP函数相同的方式进行调用。

例如，要在您的一个视图文件中使用 ``anchor()`` 函数创建链接，请执行以下操作::

	<?php echo anchor('blog/comments', 'Click Here');?>

其中 ``Click Here`` 是链接的名称，``blog/comments`` 是您要链接的控制器/方法的URI。

“继承” 辅助函数
===================

要 “继承” 辅助函数，请在您的 **app/Helpers/** 文件夹中创建一个与现有辅助函数名称相同的文件。

如果您需要做的就是向现有的辅助函数添加一些功能-可能添加一个或两个功能，或者更改特定辅助函数功能的运行方式-那么用您的版本替换整个辅助函数就太过头了。在这种情况下，最好简单地“继承”辅助函数。

.. note:: “继承”这个词语在这里用起来太过于泛化了，因为辅助函数是面向过程且离散的，并且不能在传统的程序意义上进行继承。在后台，这使您能够添加或替换Helper提供的功能。

例如，要继承本机 **Array Helper**，您将创建一个名为 **app/Helpers/array_helper.php** 的文件，并添加或覆盖函数::

	// any_in_array() 并不是数组辅助函数，因为被定义为一个新的函数
	function any_in_array($needle, $haystack)
	{
		$needle = is_array($needle) ? $needle : [$needle];

		foreach ($needle as $item)
		{
			if (in_array($item, $haystack))
			{
				return TRUE;
			}
	        }

		return FALSE;
	}

	// random_element() 在数组辅助函数中被定义了，所以在这里重载了原生的函数
	function random_element($array)
	{
		shuffle($array);
		return array_pop($array);
	}

**helper()** 方法会扫描所有 **app/Config/Autoload.php** 里定义的PSR-4命名空间并同时加载所有匹配的辅助文件，这一行为将使得所有模块的辅助文件都会被加载，包括所有你所创建用于该程序的对应辅助文件。加载顺序如下:

1. app/Helpers - 始终首先加载此处加载的文件。
2. {namespace}/Helpers - 所有命名空间按照定义的顺序循环遍历。
3. system/Helpers - 基本文件最后加载

现在怎么办？
============

在目录中，您将找到所有可用的辅助函数的列表。请逐一浏览它们的用途吧。
