###################
日志信息
###################

.. contents::
    :local:
    :depth: 2

您可以使用 ``log_message()`` 方法将信息记录到本地日志文件中。您必须在第一个参数中提供错误的“级别”，以指示错误的消息类型（调试，错误等）。第二个参数是消息本身::

	if ($some_var == '')
	{
		log_message('error', 'Some variable did not contain a value.');
	}

有八种不同的日志级别，与 `RFC 5424 <https://tools.ietf.org/html/rfc5424>`_ 级别匹配，如下所示:

* **debug** - 详细的调试信息。
* **info** - 应用程序中有趣的事件，例如用户登录，记录SQL查询等。
* **notice** - 应用程序中的正常事件，但是重要事件。
* **warning** - 并非错误的异常事件，例如使用已弃用的API，对API的不良使用或其他不一定错误的不良情况。
* **error** - 运行时错误，不需要立即采取措施，但通常应记录和监视。
* **critical** - 紧急情况，例如应用程序组件不可用或意外异常。
* **alert** - 必须立即采取措施，例如当整个网站关闭，数据库不可用等时。
* **emergency** - 系统无法使用。

日志记录系统不提供向系统管理员或网站管理员警告这些事件的方法，它们仅记录信息。对于许多更关键的事件级别，日志记录由错误处理程序自动触发，如上所述。

配置
=============

您可以在 ``/app/Config/Logger.php`` 配置文件中修改实际记录的级别，以及分配不同的Logger以处理不同的级别。

``threshold`` 配置文件的值确定跨应用程序记录的级别。如果应用程序要求记录任何级别，但是阈值不允许它们当前记录，则将忽略它们。使用的最简单方法是将此值设置为要记录的最小级别。例如，如果要记录警告消息而不是信息消息，则可以将阈值设置为5。级别为5或以下（包括运行时错误，系统错误等）的任何日志请求都将被记录，并且信息，通知和调试将被忽略::

	public $threshold = 5;

关于报错级别和对应的阈值的列表列举在配置文件中以供参阅。

你可以通过给报错阈值赋值一个包含报错等级数字的数组，来选择特定的报错级别::

	// 只记录debug和info类型的报错
	public $threshold = [5, 8];

使用多个日志处理程序
---------------------------

日志系统支持同时使用多种调度器来处理日志记录。每一种调度器可以独立地设置用于特定的错误等级，并忽略其他的。现状而言，我们默认安装了两种调度器以供使用：

- **File Handler** 是默认的调度器，它将会每天在本地创建一个独立的日志文件，同时这也是较为被推荐的日志记录方式。
- **ChromeLogger Handler** 如果你在Chrome浏览器上安装了 `ChromeLogger 扩展 <https://craig.is/writing/chrome-logger>`_ ，你可以使用这种调度器将日志输出到Chrome的控制台窗口中。
  

调度器配置于主配置文件中的 ``$handlers`` 属性中，这一属性的格式为一个包含一组调度器和它们对应的配置的数组。 每个调度器被定义数组的键，格式为完整命名空间格式的类名，而对应的值就是一个数组。 每个调度器配置块中都会有一个通用的属性： ``handles`` ，对应着该调度器将要记录的报错级别的 *名字*。

::

	public $handlers = [

		//--------------------------------------------------------------------
		// File Handler
		//--------------------------------------------------------------------

		'CodeIgniter\Log\Handlers\FileHandler' => [

			'handles' => ['critical', 'alert', 'emergency', 'debug', 'error', 'info', 'notice', 'warning'],
		]
	];

修改上下文消息
==================================

我们经常会根据上下文来修改记录信息的某些细节。比如说，可能会记录用户ID，IP地址，当前的POST变量等。 你可以通过在信息中使用通配符来实现。每个通配符必须被大括号（{}） 包裹起来。在第三个参数中，你需要提供一个包含有通配符名，与其对应值的数组。 这些内容将会插入到记录信息的字符串中::

	// 生成一条例如这样的信息：用户123登录系统，登录IP为127.0.0.1
	$info = [
		'id' => $user->id,
		'ip_address' => $this->request->ip_address()
	];

	log_message('info', 'User {id} logged into the system from {ip_address}', $info);

如果要记录“异常”或“错误”，则可以使用“exception”键，其值为“异常”或“错误”本身。将从该对象生成一个字符串，其中包含错误消息，文件名和行号。您仍然必须在消息中提供异常通配符::

	try
	{
		... 一些能抛出异常的代码
	}
	catch (\Exception $e)
	{
		log_message('error', '[ERROR] {exception}', ['exception' => $e]);
	}

存在几个核心通配符，这些通配符将根据当前页面请求为您自动扩展:

+----------------+---------------------------------------------------+
| 通配符         | 插入的值                                          |
+================+===================================================+
| {post_vars}    | $_POST 变量                                       |
+----------------+---------------------------------------------------+
| {get_vars}     | $_GET 变量                                        |
+----------------+---------------------------------------------------+
| {session_vars} | $_SESSION 变量                                    |
+----------------+---------------------------------------------------+
| {env}          | 当前环境名称, 即 development                      |
+----------------+---------------------------------------------------+
| {file}         | 调用记录器的文件名                                |
+----------------+---------------------------------------------------+
| {line}         | {file}中调用记录器的行                            |
+----------------+---------------------------------------------------+
| {env:foo}      | $_ENV中'foo'的值                                  |
+----------------+---------------------------------------------------+

使用第三方记录器
=========================

您可以使用任何其他记录器，只要它从 ``Psr\Log\LoggerInterface`` 与 `PSR3 <https://www.php-fig.org/psr/psr-3/>`_ 任一记录器扩展并且兼容即可。这意味着您可以轻松地将其用于任何与PSR3兼容的记录器，也可以创建自己的记录器。

您必须确保通过将第三方记录器添加到 ``/app/Config/Autoload.php`` 配置文件中，或通过其他自动加载器（例如Composer）将其添加到系统中。接下来，您应该修改 ``/app/Config/Services.php`` 以将 ``logger`` 别名指向您的新类名称。

现在，通过 ``log_message()`` 函数完成的任何调用都将使用您的库。

LoggerAware Trait
=================

如果您想以与框架无关的方法来实现您的库，则可以使用 ``CodeIgniter\Log\LoggerAwareTrait`` 来实现 ``setLogger()`` 方法。然后，当您在不同环境下的框架中使用库时，只要库可以找到与PSR3兼容的记录器，库仍应能够按预期进行记录。
